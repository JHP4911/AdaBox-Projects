# ESP32 (26) – UART

_Captured: 2017-11-06 at 10:49 from [www.lucadentella.it](http://www.lucadentella.it/en/2017/11/06/esp32-26-uart/)_

UART (**U**niversal **A**synchronous **R**eceiver-**T**ransmitter) is an _hardware_ peripheral which allows **serial**, asynchronous communication with configurable data format and speed. The UART interface usually works at **logic level**: the electric signals are generated by an external circuit, following the standards of the **communication bus** you chose.

For example the classical "serial port" of many personal computers is based on the [EIA RS-232](https://it.wikipedia.org/wiki/EIA_RS-232) standard, which defines how - at the **physical layer** - signals are generated on the communication medium. There are dedicated chips (the most famous of which is surely the [MAX232](https://www.maximintegrated.com/en/products/interface/transceivers/MAX232.html) by Maxim Integrated) to convert the logic levels of a UART peripheral to the physical signals of the EIA RS232 standard:

![uart-001](http://www.lucadentella.it/blog/wp-content/uploads/2017/10/uart-001.jpg)

The esp32 chip offers **3 UART controllers**. These controllers are connected to the GPIO matrix; this allows to assign them most of the digital pins of the chip:

![uart-002](http://www.lucadentella.it/blog/wp-content/uploads/2017/10/uart-002.jpg)

The _esp-idf_ _framework_ includes a **driver** (uart.c) to simplify the configuration and the use of the controllers; to use it, include its _header_ file in your program:
    
    
    #include "driver/uart.h"

For the driver, the 3 controllers are named as follows:

![uart-003](http://www.lucadentella.it/blog/wp-content/uploads/2017/10/uart-003.jpg)

> _In this first post, I'll explain the basic use of a controller; events and interrupts will be covered in a future article._

The first thing to do is to configure the controller using the **uart_config_t **struct:
    
    
    uart_config_t uart_config = {
      .baud_rate = 115200,
      .data_bits = UART_DATA_8_BITS,
      .parity = UART_PARITY_DISABLE,
      .stop_bits = UART_STOP_BITS_1,
      .flow_ctrl = UART_HW_FLOWCTRL_DISABLE
    };

  * **baud_rate** is the transmission speed
  * **data_bits**, and **stop_bits** are the number of bits for each "word" and the number of stop bits
  * **parity** defines if the controller must send the parity bit or not
  * **flow_ctrl** is the type of flow control (_hardware_, _software_ or _disabled_)

There are two additional parameters (**rx_flow_ctrl_thresh** and **use_ref_tick**) you can use to set the threshold for the RTS signal if hardware flow control is selected and to enable the REF_TICK signal as _clock _for the UART controller.

The constant values for **data_bits**, **stop_bits**… are declared in the [uart.h](https://github.com/espressif/esp-idf/blob/master/components/driver/include/driver/uart.h) file.

Often the parameters required to communicate with a serial device are expressed in a "condensed" format, for example if you read **9600,8N1** it means:

  * speed **9600** baud
  * "word" of **8** bits
  * **N**o parity
  * **1** stop bit

Configure the controller with the method:
    
    
    uart_param_config(uart_port_t uart_num, const uart_config_t *uart_config);

passing as parameters the number of the controller (**uart_num**) and the struct with the configuration previously defined (**uart_config**).

Conclude the configuration setting the pins the controller have to use for the different signals:
    
    
    uart_set_pin(uart_port_t uart_num, int tx_io_num, int rx_io_num, 
      int rts_io_num, int cts_io_num);

You can use the UART_PIN_NO_CHANGE constant if that specific signal is not used or if you want to keep the _default_ pin.

For example to map the controller to pins 4 and 5 without using the RTS and CTS signals:

Now you can install the driver with:

In addition to the controller number, you have to pass the size for the receive and transmit **buffers**. The parameters about _queue _and _interrupts_ will be discussed in a future article.

Let's now learn how to **send data**. To better understand the differences between the available commands, you have to understand that there are **two buffers**: one _hardware_, included in the UART controller, and one _software_, implemented in the driver:

![uart-004](http://www.lucadentella.it/blog/wp-content/uploads/2017/10/uart-004.jpg)

> _The first command to send data - to be used only if the software trasmit buffer is disabled - is_

**uart_tx_chars()**:

This command sends _len_ bytes from _buffer_. As you're not using a software buffer, it may happens that the command cannot send all the bytes because the hardware buffer is full; the uart_tx_chars method therefore returns the number of bytes **actually sent**.

To use the software buffer, the **uart_write_bytes() **is available:

This command copies _size_ bytes from the _src _array to the driver's buffer: the driver will take care of filling the hardware buffer of the controller until all the data is transmitted. The uart_write_bytes() also retuns the number of bytes actually copied in the tx buffer.

When **receiving**, you can use the **uart_read_bytes() **command:

The command reads a maximum of _length_ bytes from the receive buffer and copies them in the _buf _array. The command waits for data the number of specified _ticks_, then returns the number of bytes actually read.

You can know the number of bytes at each moment available in the receive buffer with:

#### UART and stdio

The _framework_ allows to use a UART controller as a peripheral for standard I/O. Unix _streams_ **stdin**, **stdout **and **stderr **are indeed linked to RX and TX operations on that controller: you can therefore use standard C functions like **printf()**, **scanf()**… to write and read from the UART controller.

Via **menuconfig** you can specify which controller to use, the parameters for the controller and you can also disable this feature at all:

![uart-005](http://www.lucadentella.it/blog/wp-content/uploads/2017/10/uart-005.jpg)

#### Demo

In the following video I'll show how to work with UART controllers connecting one of them to a USB->serial converter. Both the converter and the esp32 devboard are connected to my laptop: in this way I can send data from the laptop to UART1 via the converter, read it and send it back to my laptop using the UART0 controller.
